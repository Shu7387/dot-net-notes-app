<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style.css" />
    <title>ASP.NET Core Web API Notes</title>
  </head>
  <body>
    <h1>3. ASP.NET CORE WEB API</h1>

    <!-- ===================== SECTION 1 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 1: REST &amp; HTTP Fundamentals <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>REST Principles:</strong> Stateless, resource-based URLs,
          standard HTTP verb methods, JSON response, gives status codes
        </li>
        <li>
          <strong>REST vs SOAP:</strong> REST is lightweight, follows REST
          principles, mainly uses JSON, best for modern web apps and
          microservices. SOAP is XML-based, heavyweight, has strict standards,
          commonly used in enterprise systems requiring strong security and
          transactions.
        </li>
        <li>
          <strong>HTTP Methods:</strong> <code>GET</code> (read),
          <code>POST</code> (create), <code>PUT</code> (full update),
          <code>PATCH</code> (partial update), <code>DELETE</code> (remove)
        </li>
        <li>
          <strong>Content Negotiation:</strong> Client request header:
          <code>Accept: application/json</code>; API response:
          <code>Content-Type</code>
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 2 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 2: Controllers &amp; Routing <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>ApiController attribute:</strong> Auto model validation,
          automatic 400 responses, auto model binding (source inference)
          <code>[ApiController]</code>
        </li>
        <li>
          <strong>Action Results:</strong>
          <code>ActionResult&lt;T&gt;</code> (data + statusCode),
          <code>CreatedAtAction()</code>, <code>Ok(student)</code>,
          <code>NoContent()</code>, <code>NotFound()</code>,
          <code>BadRequest()</code>
        </li>
        <li>
          <strong>Minimal APIs:</strong> Modern Web API style using
          <code>app.MapGet/Post/Put/Delete</code>; no controllers; cleaner and
          lightweight for simple APIs
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 3 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 3: Entity Framework Core Integration
      <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>DbContext / DbSet:</strong> DbContext represents DB &amp;
          tracks DB session; <code>DbSet&lt;T&gt;</code> represents a table
        </li>
        <li>
          <strong>LINQ Queries:</strong> Use <code>Where</code>,
          <code>Select</code>, <code>Join</code>;
          <code>FromSqlRaw("EXEC usp_GetStudent, @id", param)</code>
        </li>
        <li>
          <strong>Async Operations:</strong> Use <code>ToListAsync()</code>,
          <code>FirstOrDefaultAsync()</code>, <code>SaveChangesAsync()</code>
        </li>
        <li>
          <strong>Change Tracking &amp; AsNoTracking():</strong> EF tracks by
          default for updates; use <code>AsNoTracking()</code> for read-only
          queries for better performance
        </li>
        <li>
          <strong>N+1 Problem:</strong> One query loads main data and N extra
          queries load related data. Fix: use <code>Include()</code> /
          <code>ThenInclude()</code> to load related data in 1 query; avoid lazy
          loading
        </li>
        <li>
          <strong>Relationships &amp; Keys:</strong> Configure one-to-many,
          many-to-many relations, PKs, FKs, and cascade rules
        </li>
        <li>
          <strong>Indexes:</strong> Fluent API <code>HasIndex(...)</code> or
          annotation <code>[Index(nameof(Email), IsUnique = true)]</code>
        </li>
        <li>
          <strong>Pagination:</strong>
          <code>OrderBy(...).Skip((page - 1) * size).Take(size)</code>
        </li>
        <li>
          <strong>Transactions &amp; Concurrency:</strong> Use
          <code>BeginTransactionAsync</code>, <code>CommitAsync</code>,
          <code>RollbackAsync</code>; use <code>[Timestamp]</code> /
          <code>RowVersion</code> for optimistic concurrency
        </li>
        <li>
          <strong>Global Query Filters:</strong> Defined at model level using
          <code>HasQueryFilter(...)</code>; auto-applied to every query; used
          for soft delete and multi-tenant filtering; bypass with
          <code>IgnoreQueryFilters()</code>
        </li>
        <li>
          <strong>Compiled Queries:</strong> EF translates LINQ to SQL each
          time; use <code>EF.CompileQuery()</code> for high-frequency queries to
          reduce translation overhead
        </li>
      </ul>

      <div class="note">
        <p><strong>EF Optimization:</strong></p>
        <p>
          Use <code>AsNoTracking</code> for reads, load only required data, add
          indexes on hot columns, avoid N+1 with
          <code>Include</code>/projection, use pagination, handle concurrency
          with <code>RowVersion</code>, apply global query filters for soft
          delete/tenants, and use compiled queries for high-frequency paths.
        </p>
      </div>

      <div class="note">
        <p><strong>DB First:</strong></p>
        <p>
          Create Database â†’ Install EF Core packages â†’ Configure connection
          string â†’ Run <code>Scaffold-DbContext</code> â†’ EF generates
          <code>DbContext</code> &amp; entity models â†’ Register in
          <code>Program.cs</code> â†’ Use via Repository â†’ Handler CQRS â†’
          Controller. <strong>Later changes:</strong> Alter DB using SQL, then
          update EDMX file.
        </p>
      </div>

      <div class="note">
        <p><strong>Code First:</strong></p>
        <p>
          Create Web API project â†’ Install EF Core â†’ Configure connection string
          â†’ Create Entity classes â†’ Create <code>DbContext</code> â†’ Register in
          <code>Program.cs</code> â†’ <code>Add-Migration</code> â†’
          <code>Update-Database</code> â†’ Use via Repository â†’ Handler CQRS â†’
          Controller. <strong>Later changes:</strong> Update entity class, add
          migration, run Update-Database.
        </p>
      </div>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 4 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 4: ADO.NET <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>What is ADO.NET:</strong> A simple .NET library to talk to a
          database â€” open a connection, run SQL or stored procedures, read
          results, and keep data in memory (<code>DataTable</code> /
          <code>DataSet</code>)
        </li>
        <li>
          <strong>Core Classes:</strong> <code>SqlConnection</code>,
          <code>SqlCommand</code>, <code>SqlDataReader</code>,
          <code>SqlDataAdapter</code>, <code>DataTable</code>,
          <code>DataSet</code>, <code>SqlParameter</code>,
          <code>SqlTransaction</code>
        </li>
        <li>
          <strong>Connected vs Disconnected:</strong>
          <code>SqlDataReader</code> â€” fast, row-by-row, connection stays open.
          <code>DataAdapter</code> + <code>DataTable</code> â€” edit in memory and
          save later, connection can be closed
        </li>
        <li>
          <strong>Execute Methods:</strong> <code>ExecuteScalar()</code> â†’ one
          value (COUNT/SUM); <code>ExecuteNonQuery()</code> â†’ rows affected
          (INSERT/UPDATE/DELETE); <code>ExecuteReader()</code> â†’ many rows
        </li>
        <li>
          <strong>Parameters &amp; SQL Injection:</strong> Always use parameters
          â€”
          <code>cmd.Parameters.Add("@id", SqlDbType.Int).Value = id;</code>
          Never build SQL by joining strings with user input
        </li>
        <li>
          <strong>Using / Disposal:</strong> Use <code>using</code> so
          <code>SqlConnection</code>, <code>SqlCommand</code>, and
          <code>SqlDataReader</code> are closed and returned to pool
        </li>
        <li>
          <strong>Connection Pooling:</strong> ADO.NET handles pooling
          automatically; tune via connection string:
          <code>Pooling=true;Min Pool Size=5;Max Pool Size=100;</code> â€” open
          late, close early
        </li>
        <li>
          <strong>Transactions:</strong> Use <code>BeginTransaction()</code> /
          <code>Commit()</code> / <code>Rollback()</code> or
          <code>TransactionScope</code> for grouped operations
        </li>
        <li>
          <strong>Bulk Operations:</strong> Use <code>SqlBulkCopy</code> to
          insert many rows fast from a <code>DataTable</code> or
          <code>IDataReader</code>
        </li>
        <li>
          <strong>Stored Procedures:</strong> Set
          <code>cmd.CommandType = CommandType.StoredProcedure</code>, add
          input/output parameters, then execute
        </li>
        <li>
          <strong>Async API:</strong> Use <code>OpenAsync()</code>,
          <code>ExecuteReaderAsync()</code>,
          <code>ExecuteNonQueryAsync()</code>,
          <code>ExecuteScalarAsync()</code>
        </li>
      </ul>

      <div class="note">
        <p>
          <strong>Best Practices:</strong> Select only needed columns; always
          use parameters; always close connections with <code>using</code>; use
          <code>SqlDataReader</code> for fast reads; use
          <code>SqlBulkCopy</code> for large imports; keep transactions short;
          use async methods in web/API code.
        </p>
      </div>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 5 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 5: Life Cycles &amp; Authentication &amp; Authorization
      <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p><strong>Life Cycles:</strong></p>
        <p>
          <strong>Angular:</strong> Browser â†’ index.html â†’ main.ts â†’ AppModule â†’
          AppComponent â†’ Other Components â†’ API calls â†’ UI Render
        </p>
        <p>
          <strong>Web API:</strong> Client â†’ API Middleware â†’ Routing â†’
          Controller &amp; Action â†’ Service / DB â†’ Controller â†’ Middleware â†’
          Response
        </p>
        <p>
          <strong>MVC:</strong> Browser â†’ MVC Middleware â†’ Routing â†’ Controller
          &amp; Action â†’ API / DB â†’ Controller â†’ View (HTML) â†’ Middleware â†’
          Browser
        </p>
      </div>

      <div class="note">
        <p><strong>Authentication &amp; Authorization:</strong></p>
        <ul>
          <li>
            <strong>Identity manager:</strong> Claims (Age: 30, Role: Admin) â†’
            Identity (Pan card) â†’ Principal (Shubham) â†’ HttpContext.User
          </li>
          <li>
            <strong>User registers MVC:</strong> UserManager creates user &amp;
            RoleManager assigns role â†’ stored in DB
          </li>
          <li>
            <strong>User logins MVC:</strong> SignInManager validates â†’ auth
            cookie created &amp; sent to browser â†’ browser sends it with each
            request â†’ MVC validates via <code>[Authorize(Roles=â€¦)]</code>
          </li>
          <li>
            <strong>User logins Angular:</strong> LoginComponent â†’ AuthService â†’
            API â†’ validates credentials â†’ creates JWT â†’ returns to Angular â†’
            stored in browser
          </li>
          <li>
            <strong>Next request:</strong> Route Guards check auth &amp; roles;
            Interceptor adds token to API calls â†’ API validates JWT â†’ returns
            data â†’ Angular renders UI
          </li>
        </ul>
      </div>

      <table>
        <thead>
          <tr>
            <th>Topic</th>
            <th>Purpose</th>
            <th>Steps</th>
            <th>Key Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Refresh Token</strong></td>
            <td>Handle JWT expiry</td>
            <td>
              API issues JWT (short-lived) + Refresh token (long-lived); on 401,
              client calls refresh API to get new JWT â€” no re-login
            </td>
            <td>
              Access token sent with API calls; refresh token used only on
              expiry
            </td>
          </tr>
          <tr>
            <td><strong>JWT Authentication</strong></td>
            <td>Stateless user authentication</td>
            <td>
              Install JwtBearer, configure Issuer, Audience, SigningKey in
              config
            </td>
            <td>
              Must call <code>UseAuthentication()</code> before
              <code>UseAuthorization()</code>
            </td>
          </tr>
          <tr>
            <td><strong>JWT Token Generation</strong></td>
            <td>Issue token after login</td>
            <td>
              Validate credentials â†’ Create Claims â†’ Generate
              <code>JwtSecurityToken</code>
            </td>
            <td>
              JWT = Header + Payload + Signature; contains user identity &amp;
              role
            </td>
          </tr>
          <tr>
            <td><strong>JWT Token Usage</strong></td>
            <td>Authenticate each request</td>
            <td>
              Client stores token â†’ sends via
              <code>Authorization: Bearer &lt;token&gt;</code>
            </td>
            <td>API validates token on every request</td>
          </tr>
          <tr>
            <td><strong>Role/Policy Authorization</strong></td>
            <td>Control access by role</td>
            <td>
              <code>[Authorize]</code>, <code>[Authorize(Roles="Admin")]</code>,
              <code>[Authorize(Policy="AdultAdmin")]</code>
            </td>
            <td>Role read from JWT claims; 403 if role missing</td>
          </tr>
          <tr>
            <td><strong>OAuth</strong></td>
            <td>Token-based; no creds exposed</td>
            <td>MVC sends OAuth token to API; API validates it</td>
            <td>Token issued by external auth server</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 6 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 6: Cache <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Cache Type</th>
            <th>Stored Where</th>
            <th>Purpose</th>
            <th>Setup</th>
            <th>When to Use</th>
            <th>Key Point</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>In-Memory Cache</strong></td>
            <td>App RAM</td>
            <td>Cache data (DB results, config)</td>
            <td><code>AddMemoryCache()</code></td>
            <td>Single server apps</td>
            <td>Fast; lost on restart/crash; not shared across servers</td>
          </tr>
          <tr>
            <td><strong>Distributed Cache (Redis)</strong></td>
            <td>External store</td>
            <td>Shared cache across servers</td>
            <td><code>AddStackExchangeRedisCache()</code></td>
            <td>Load-balanced apps</td>
            <td>Scalable; shared across servers</td>
          </tr>
          <tr>
            <td><strong>Output Cache</strong></td>
            <td>Server</td>
            <td>Cache full action output</td>
            <td>
              <code>AddOutputCache()</code>,
              <code>[OutputCache(Duration=60)]</code>
            </td>
            <td>Modern MVC / API apps</td>
            <td>Caches actual method response</td>
          </tr>
          <tr>
            <td><strong>Response Cache</strong></td>
            <td>Client / Proxy</td>
            <td>Cache HTTP GET responses</td>
            <td>
              <code>AddResponseCaching()</code>,
              <code>[ResponseCache(Duration=60)]</code>
            </td>
            <td>Public read-only APIs</td>
            <td>Caches response headers only</td>
          </tr>
          <tr>
            <td><strong>HTTP Browser Cache</strong></td>
            <td>Browser</td>
            <td>Avoid re-downloading data</td>
            <td>Response headers</td>
            <td>Static / semi-static data</td>
            <td>Tells browser to cache</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 7 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 7: Performance &amp; Optimization
      <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>DTO Shaping:</strong> Return only required fields; avoid
          sending full entities to reduce JSON size
        </li>
        <li>
          <strong>Avoid Over-Serialization:</strong> Send only required data
          using DTOs; disable lazy loading; avoid circular references
        </li>
        <li>
          <strong>Pagination &amp; Filtering:</strong> Pagination limits result
          size; filtering narrows results â€” use <code>AsQueryable()</code>
        </li>
        <li>
          <strong>API-Level Caching:</strong> Cache expensive responses using
          In-Memory, distributed cache (Redis), or response caching
        </li>
        <li>
          <strong>Compression:</strong> Use
          <code>UseResponseCompression</code> middleware (Gzip/Brotli) to reduce
          response size
        </li>
        <li>
          <strong>Health Checks:</strong> Endpoints to verify app &amp;
          dependencies (DB/cache) are running; load balancer uses it to check
          API availability
        </li>
        <li>
          <strong>Use async/await:</strong> Avoid blocking calls like
          <code>.Result</code> or <code>.Wait()</code>
        </li>
        <li>
          <strong>Rate Limiting:</strong> Limits client requests to protect API;
          define policy in <code>Program.cs</code>, apply with
          <code>[EnableRateLimiting]</code>; returns
          <code>429 Too Many Requests</code>
        </li>
      </ul>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 8 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 8: Setups <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Topic</th>
            <th>Purpose</th>
            <th>How to Implement</th>
            <th>Where to Register</th>
            <th>Key Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Custom Error Middleware</strong></td>
            <td>Centralized exception handling</td>
            <td>
              Create middleware with <code>RequestDelegate</code>; implement
              <code>InvokeAsync()</code> with try-catch
            </td>
            <td><code>app.UseMiddleware&lt;ExceptionMiddleware&gt;()</code></td>
            <td>Handles all unhandled exceptions; place early in pipeline</td>
          </tr>
          <tr>
            <td><strong>Global Exception Filter</strong></td>
            <td>Controller-scoped exception handling</td>
            <td>
              Implement <code>IExceptionFilter</code> or inherit
              <code>ExceptionFilterAttribute</code>
            </td>
            <td>
              <code>options.Filters.Add&lt;...&gt;()</code> in
              <code>Program.cs</code>
            </td>
            <td>Applies only to MVC pipeline, not middleware</td>
          </tr>
          <tr>
            <td><strong>AutoMapper</strong></td>
            <td>Map Entity â†” DTO automatically</td>
            <td>
              Install AutoMapper; create class inheriting <code>Profile</code>;
              define <code>CreateMap&lt;,&gt;()</code>
            </td>
            <td><code>builder.Services.AddAutoMapper()</code></td>
            <td>Removes manual mapping; improves readability</td>
          </tr>
          <tr>
            <td><strong>Serilog</strong></td>
            <td>Structured &amp; persistent logging</td>
            <td>
              Install Serilog + sinks; configure in
              <code>appsettings.json</code>
            </td>
            <td><code>builder.Host.UseSerilog()</code></td>
            <td>
              Use <code>ILogger&lt;T&gt;</code> in app; supports file, console,
              Seq
            </td>
          </tr>
          <tr>
            <td><strong>Swagger</strong></td>
            <td>API documentation &amp; testing</td>
            <td>Install Swashbuckle; configure in <code>Program.cs</code></td>
            <td>
              <code>app.UseSwagger()</code> &amp;
              <code>app.UseSwaggerUI()</code>
            </td>
            <td>Add Bearer security definition for JWT</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 9 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 9: Microservices Essentials <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Monolith</strong></td>
            <td>
              Everything in one unit; hard to scale, deploy, maintain; big
              failures; forced same technology
            </td>
          </tr>
          <tr>
            <td><strong>Architecture</strong></td>
            <td>
              Small, independent services built around business capabilities
            </td>
          </tr>
          <tr>
            <td><strong>Single Responsibility</strong></td>
            <td>
              One service, one job; loose coupling and independent changes
            </td>
          </tr>
          <tr>
            <td><strong>Database per Service</strong></td>
            <td>Each service owns its data; no shared databases</td>
          </tr>
          <tr>
            <td><strong>Communication</strong></td>
            <td>
              REST/gRPC (synchronous) or messaging/events (async: RabbitMQ,
              Kafka)
            </td>
          </tr>
          <tr>
            <td><strong>RabbitMQ</strong></td>
            <td>
              Queue-based async communication between APIs (Order API â†’ RabbitMQ
              â†’ Email API)
            </td>
          </tr>
          <tr>
            <td><strong>Observability</strong></td>
            <td>
              Centralized logging (Serilog) and distributed tracing across
              services (CorrelationId)
            </td>
          </tr>
          <tr>
            <td><strong>Security</strong></td>
            <td>JWT-based auth; service-to-service security via API Gateway</td>
          </tr>
          <tr>
            <td><strong>Containers</strong></td>
            <td>Docker for packaging; Kubernetes for orchestration</td>
          </tr>
          <tr>
            <td><strong>CI/CD</strong></td>
            <td>Automated builds and independent deployments per service</td>
          </tr>
          <tr>
            <td><strong>Resilience (Polly)</strong></td>
            <td>
              Retry, timeout, circuit breaker â€” handles transient failures
            </td>
          </tr>
          <tr>
            <td><strong>When NOT to Use</strong></td>
            <td>
              Small apps, low complexity, tight timelines, weak DevOps maturity
            </td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 10 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 10: Miscellaneous <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>launchSettings.json:</strong> Local app launch configs;
          defines environment, URLs, profiles, and
          <code>ASPNETCORE_ENVIRONMENT</code>
        </li>
        <li>
          <strong>HTTP Status Codes:</strong> <code>200 OK</code>,
          <code>201 Created</code>, <code>204 NoContent</code>,
          <code>400 BadRequest</code>, <code>401 Unauthorized</code>,
          <code>403 Forbidden</code>, <code>404 NotFound</code>,
          <code>409 Conflict</code>, <code>429 Too Many Requests</code>,
          <code>500 Internal Server Error</code>
        </li>
        <li>
          <strong>API Versioning:</strong> Maintain multiple API versions for
          clients (e.g. <code>/api/v1/users</code>); install versioning package,
          configure in <code>Program.cs</code>
        </li>
        <li>
          <strong>HTTPS:</strong> Secures client-server communication by
          encrypting data using SSL/TLS certificates
        </li>
        <li>
          <strong>Layered Architecture:</strong> Thin Controller â†’ Request
          Handler (CQRS) â†’ Service/Repository â†’ DbContext â†’ Database
        </li>
        <li>
          <strong>CORS:</strong> Security feature controlling which frontend
          apps can access APIs; configured in <code>Program.cs</code>
        </li>
        <li>
          <strong>FluentValidation:</strong> External library; defines
          validation rules in separate classes; more powerful than data
          annotations
        </li>
        <li>
          <strong>ProblemDetails:</strong> Standard API error response format:
          title, status, detail, errors
        </li>
        <li>
          <strong>Correlation ID:</strong> Unique request ID to trace logs &amp;
          calls across services; set via HTTP headers, middleware,
          <code>Guid()</code>
        </li>
        <li>
          <strong>Idempotency:</strong> Repeating the same request gives the
          same result; client sends Idempotency-Key in header; API stores result
          in cache (Redis/SQL) and returns same response for retries â€” prevents
          duplicate actions
        </li>
        <li>
          <strong>API Gateway:</strong> Sits between client and backend APIs;
          single entry point; handles auth, rate limiting, logging â€” MVC â†’ API
          Gateway â†’ All Backend APIs
        </li>
        <li>
          <strong>Securing Web API:</strong> JWT via <code>AddJwtBearer</code>;
          <code>UseAuthentication</code> +
          <code>UseAuthorization</code> middleware;
          <code>[Authorize]</code> attribute; HTTPS; CORS; rate limiting; Azure
          Key Vault for secrets
        </li>
      </ul>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 11: SCENARIOS ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 11: Scenario-Based Questions <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="scenario-item">
        <h3>1. JWT Expires Mid-Session</h3>
        <p>
          Users get logged out randomly and see 401 errors while actively using
          the app. JWT tokens expire after 15 minutes. How do you keep sessions
          alive without forcing re-login?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Issue two tokens on login â€” a short-lived JWT access token (15 min)
            and a long-lived refresh token (7â€“30 days). When the client receives
            a 401, it silently calls the refresh endpoint to get a new access
            token â€” no re-login needed. Store the refresh token in an HttpOnly
            cookie (not localStorage) and rotate it on each use. Invalidate it
            on logout.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>2. N+1 Query Problem in EF Core</h3>
        <p>
          An endpoint returning orders with customer details works fine with 10
          records but takes 30 seconds with 1000. DB logs show hundreds of
          separate queries firing. What's wrong and how do you fix it?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            EF loads orders in 1 query, then fires a separate query per order to
            get the customer â€” that's N+1. Fix with eager loading:
            <code>context.Orders.Include(o =&gt; o.Customer).ToListAsync()</code
            >. For better performance, use projection with
            <code>Select()</code> to fetch only the fields needed in the
            response â€” this avoids loading full entities and reduces data
            transfer.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>3. Two Users Overwriting Each Other's Changes</h3>
        <p>
          User A and User B both open the same product. User A saves price $100,
          then User B saves $120. User A's change is silently lost with no
          error. How do you prevent this?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Use optimistic concurrency with a <code>RowVersion</code> column â€”
            <code>[Timestamp] public byte[] RowVersion { get; set; }</code>. EF
            automatically includes it in the WHERE clause on update. If the
            version doesn't match (someone else already saved), EF throws
            <code>DbUpdateConcurrencyException</code>. Catch it and return
            <code>409 Conflict</code> so the user can refresh and retry with the
            latest data.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>4. Attacker Sets IsAdmin = true in Request Body</h3>
        <p>
          Your user update endpoint accepts a User entity directly. An attacker
          adds <code>"IsAdmin": true</code> to the JSON and successfully
          promotes themselves. How do you prevent mass assignment?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Never bind database entities directly in API requests. Use DTOs â€”
            create an <code>UpdateUserDto</code> with only the fields the user
            is allowed to change (Name, Email). Even if the attacker sends
            <code>IsAdmin</code>, it's not a property on the DTO so it's ignored
            entirely. Rule: accept DTOs as input, never accept or return raw
            entities.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>5. Inconsistent Error Responses Across Endpoints</h3>
        <p>
          Some endpoints return JSON errors, some return HTML pages, some just a
          status code. Clients can't reliably parse errors. How do you
          standardize this?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Create a global exception handling middleware that wraps the entire
            pipeline in try-catch, catches all unhandled exceptions, and always
            returns a consistent <code>ProblemDetails</code> JSON format
            (status, title, detail, traceId). Register it first in the pipeline:
            <code>app.UseMiddleware&lt;ExceptionMiddleware&gt;()</code>. Every
            error from any endpoint now returns the same structure.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>6. Angular Gets CORS Error â€” Postman Works Fine</h3>
        <p>
          Angular on <code>localhost:4200</code> can't call the API on
          <code>localhost:5000</code>. Browser shows "No
          Access-Control-Allow-Origin header." Postman has no problem. Why?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            CORS is enforced by browsers only â€” Postman bypasses it. The browser
            blocks cross-origin requests unless the API explicitly permits them.
            Fix: configure CORS in <code>Program.cs</code> â€”
            <code>builder.Services.AddCors()</code> with
            <code>WithOrigins("http://localhost:4200")</code>, then
            <code>app.UseCors()</code> in the pipeline. In production, specify
            the real deployed frontend URL. Never use
            <code>AllowAnyOrigin()</code> with credentials.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>7. User Gets Charged Twice on Double-Click</h3>
        <p>
          Users double-click "Pay Now" and the payment API processes both
          requests â€” two charges. How do you guarantee a payment is only
          processed once?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Implement idempotency. The client generates a unique GUID per
            payment and sends it in the request header. The API checks if a
            result for that key already exists in Redis or DB. If yes â€” return
            the existing result. If no â€” process, store the result with the key,
            then return. The same request can be retried safely any number of
            times and will only ever process once.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>8. API Memory Grows Until It Crashes</h3>
        <p>
          The API runs fine after deployment but memory steadily grows over days
          until it crashes. Restart fixes it temporarily. What are the likely
          causes and how do you fix them?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Most common causes: (1) <strong>DbContext as Singleton</strong> â€”
            holds tracked entities and DB connections for the app lifetime. Fix:
            always use the default Scoped lifetime via
            <code>AddDbContext()</code>. (2)
            <strong>Event subscriptions never removed</strong> â€” publisher holds
            a reference to subscriber forever. Fix: unsubscribe in
            <code>Dispose()</code>. (3)
            <strong>Static caches with no eviction</strong> growing
            indefinitely. Use a memory profiler to confirm which objects aren't
            being collected, then fix the root cause.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>9. Report Endpoint Times Out for the Client</h3>
        <p>
          A report generation endpoint takes 5 minutes. Clients timeout and see
          errors. How do you handle long-running tasks without blocking the
          client?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Don't make the client wait. Use the fire-and-forget pattern: API
            immediately returns <code>202 Accepted</code> with a job ID. The
            actual work runs in the background via a hosted service or Hangfire.
            The client polls <code>/api/reports/{id}/status</code> to check
            progress, or the API pushes a notification (SignalR / webhook) when
            done. Client stays unblocked and no timeouts occur.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>10. One Failing Service Brings Down the Whole App</h3>
        <p>
          Order API calls Payment service. Payment service goes down. Order API
          threads pile up waiting and the whole app becomes unresponsive. How do
          you prevent cascade failures?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Use the <strong>Circuit Breaker</strong> pattern via Polly. After a
            number of consecutive failures, the circuit "opens" and calls to the
            failing service immediately return a fallback response â€” threads
            don't pile up. Add a <strong>timeout policy</strong> so no single
            call waits indefinitely. Combine retry + timeout + circuit breaker
            for full resilience: <code>AddPolicyHandler()</code> in
            <code>Program.cs</code> when registering <code>HttpClient</code>.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>11. Connection String Committed to GitHub</h3>
        <p>
          A developer accidentally committed DB connection strings and API keys
          inside <code>appsettings.json</code> to a public repo. How do you fix
          it and prevent it?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Immediate action: rotate all exposed credentials. Prevention: never
            store secrets in <code>appsettings.json</code>. For local dev â€” use
            <strong>User Secrets</strong> (<code>dotnet user-secrets set</code
            >), stored outside the project and never committed. For production â€”
            use <strong>Azure Key Vault</strong> or environment variables; the
            app reads them at runtime. Add sensitive config files to
            <code>.gitignore</code>.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>
    </div>
    <!-- end section-content scenarios -->

    <script src="../change.js"></script>
  </body>
</html>
