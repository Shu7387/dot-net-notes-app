<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style.css" />
    <title>Angular Notes</title>
  </head>
  <body>
    <h1>7. Angular</h1>

    <!-- ===================== SECTION 1 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 1: Components &amp; Templates <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>Component:</strong> Reusable UI building block with its own
          template (HTML), styles (CSS), and logic (TypeScript)
        </li>
        <li>
          <strong>Component Communication:</strong> <code>@Input</code> (parent
          â†’ child), <code>@Output</code> + <code>EventEmitter</code> (child â†’
          parent)
        </li>
        <li>
          <strong>Template Syntax:</strong> Interpolation
          <code>{{value}}</code>, Property binding
          <code>[property]="value"</code>, Event binding
          <code>(event)="handler()"</code>
        </li>
        <li>
          <strong>Two-way Binding:</strong>
          <code>[(ngModel)]="property"</code> syncs data between component and
          template
        </li>
        <li>
          <strong>Template Variables:</strong> <code>#varName</code> reference
          elements â€” <code>&lt;input #email&gt;</code> then use
          <code>email.value</code>
        </li>
        <li>
          <strong>Safe Navigation:</strong>
          <code>user?.address?.city</code> prevents errors on null/undefined
        </li>
        <li>
          <strong>Async Pipe:</strong>
          <code>data$ | async</code> auto-subscribes and unsubscribes
          Observables
        </li>
        <li>
          <strong>Content Projection:</strong> Project parent content into child
          â€” Single <code>&lt;ng-content&gt;</code>, Multi
          <code>&lt;ng-content select=".class"&gt;</code>
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 2 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 2: Decorators <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Decorators:</strong> Special functions prefixed with
          <code>@</code> that add metadata or behavior to classes, properties,
          and methods
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Decorator</th>
            <th>Applied To</th>
            <th>Purpose</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>@Component</strong></td>
            <td>Class</td>
            <td>Define component</td>
            <td><code>@Component({selector, template, styles})</code></td>
          </tr>
          <tr>
            <td><strong>@Injectable</strong></td>
            <td>Class</td>
            <td>Mark service for DI</td>
            <td><code>@Injectable({providedIn: 'root'})</code></td>
          </tr>
          <tr>
            <td><strong>@Input</strong></td>
            <td>Property</td>
            <td>Child receive data from parent</td>
            <td><code>@Input() username: string;</code></td>
          </tr>
          <tr>
            <td><strong>@Output</strong></td>
            <td>Property</td>
            <td>Child send events to parent</td>
            <td><code>@Output() clicked = new EventEmitter();</code></td>
          </tr>
          <tr>
            <td><strong>@ViewChild</strong></td>
            <td>Property</td>
            <td>Access child element/component after view init</td>
            <td><code>@ViewChild('ref') element;</code></td>
          </tr>
          <tr>
            <td><strong>@ContentChild</strong></td>
            <td>Property</td>
            <td>Access projected content via <code>ng-content</code></td>
            <td>
              <code
                >@ContentChildren('ref') items!:
                QueryList&lt;ElementRef&gt;;</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>@HostListener</strong></td>
            <td>Method</td>
            <td>Listen to events on the host element</td>
            <td><code>@HostListener('click') onClick() { }</code></td>
          </tr>
          <tr>
            <td><strong>@HostBinding</strong></td>
            <td>Property</td>
            <td>Bind class, style, attribute to the host element</td>
            <td><code>@HostBinding('class.active') isActive = true;</code></td>
          </tr>
          <tr>
            <td><strong>@Directive</strong></td>
            <td>Class</td>
            <td>Define custom directive</td>
            <td><code>@Directive({selector: '[appHighlight]'})</code></td>
          </tr>
          <tr>
            <td><strong>@Pipe</strong></td>
            <td>Class</td>
            <td>Define custom pipe</td>
            <td><code>@Pipe({name: 'customFormat'})</code></td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 3 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 3: Directives <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Directives:</strong> Special attributes used in templates to
          modify the DOM's structure, appearance, or behavior â€”
          <code>&lt;p CustomDire&gt;Text&lt;/p&gt;</code>
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Type</th>
            <th>What it does</th>
            <th>Examples</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Structural</strong></td>
            <td>Add/remove DOM elements</td>
            <td>
              <code>*ngIf="condition"</code>,
              <code>*ngFor="let item of items"</code>, <code>*ngSwitch</code>
            </td>
          </tr>
          <tr>
            <td><strong>Attribute</strong></td>
            <td>Change appearance/behavior</td>
            <td>
              <code>[ngClass]="{'active': isActive}"</code>,
              <code>[ngStyle]="{'color': textColor}"</code>
            </td>
          </tr>
          <tr>
            <td><strong>New Control Flow</strong></td>
            <td>Modern syntax (v17+)</td>
            <td>
              <code>@if (condition) {}</code>,
              <code>@for (item of items; track item.id) {}</code>
            </td>
          </tr>
          <tr>
            <td><strong>Custom Directive</strong></td>
            <td>Reusable behavior</td>
            <td>
              <code>@Directive({selector: '[appHighlight]'})</code> with
              <code>@HostListener('mouseenter')</code>
            </td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 4 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 4: Lifecycle Hooks <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Lifecycle Hooks:</strong> Special methods Angular calls at
          specific moments in a component's life to execute custom logic
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Hook</th>
            <th>When It Runs</th>
            <th>Primary Use</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>ngOnInit</strong></td>
            <td>After first change detection</td>
            <td>Initialize component, fetch API data</td>
          </tr>
          <tr>
            <td><strong>ngOnChanges</strong></td>
            <td>When @Input properties change</td>
            <td>
              React to input changes â€”
              <code>ngOnChanges(changes: SimpleChanges) {}</code>
            </td>
          </tr>
          <tr>
            <td><strong>ngAfterViewInit</strong></td>
            <td>After view is initialized</td>
            <td>Access @ViewChild, DOM manipulation</td>
          </tr>
          <tr>
            <td><strong>ngOnDestroy</strong></td>
            <td>Before component is destroyed</td>
            <td>Cleanup resources, unsubscribe from Observables</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 5 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 5: Services &amp; Dependency Injection
      <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Services:</strong> Classes that contain business logic, data
          access, or shared functionality across components
        </p>
      </div>

      <ul>
        <li>
          <strong>@Injectable Decorator:</strong> Marks class as injectable
          service â€” <code>@Injectable({providedIn: 'root'})</code>
        </li>
        <li>
          <strong>providedIn: 'root':</strong> Creates singleton service
          available app-wide
        </li>
        <li>
          <strong>Constructor Injection:</strong>
          <code>constructor(private authService: AuthService) {}</code> â€”
          traditional way
        </li>
        <li>
          <strong>inject() Function:</strong>
          <code>private authService = inject(AuthService);</code> â€” modern way;
          works anywhere, not just constructors
        </li>
        <li>
          <strong>Service Scope:</strong> Root (singleton for app), Module (per
          module), Component (per instance)
        </li>
        <li>
          <strong>Use Cases:</strong> Share data, business logic, API calls,
          state management
        </li>
      </ul>

      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>Purpose</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Provider Types</strong></td>
            <td>Define how Angular creates or supplies a dependency</td>
            <td>
              <code>useClass</code>, <code>useValue</code>,
              <code>useFactory</code>, <code>useExisting</code>,
              <code>multi</code>
            </td>
          </tr>
          <tr>
            <td><strong>DI Hierarchy</strong></td>
            <td>Where Angular looks for dependencies</td>
            <td>Child â†’ Parent â†’ Module â†’ Root</td>
          </tr>
          <tr>
            <td><strong>@Optional()</strong></td>
            <td>Prevents error if dependency not found</td>
            <td><code>constructor(@Optional() service: Service)</code></td>
          </tr>
          <tr>
            <td><strong>@Self / @SkipSelf / @Inject</strong></td>
            <td>
              Control how Angular searches dependency in injector hierarchy
            </td>
            <td>
              <code>constructor(@Self() private log: LogService)</code
              ><br /><code>constructor(@Inject(TOKEN) name: string)</code>
            </td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 6 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 6: Routing <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Routing:</strong> Navigation system that maps URL paths to
          components, enabling single-page application behavior
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>What it does</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Basic Routes</strong></td>
            <td>Map URL to components</td>
            <td>
              <code>{ path: 'home', component: HomeComponent }</code><br /><code
                >Router</code
              >
              (navigate), <code>ActivatedRoute</code> (read params),
              <code>Routes</code> (config)
            </td>
          </tr>
          <tr>
            <td><strong>Route Params</strong></td>
            <td>Pass dynamic values in URL</td>
            <td><code>{path: 'user/:id', component: UserComponent}</code></td>
          </tr>
          <tr>
            <td><strong>Child Routes</strong></td>
            <td>Nested navigation</td>
            <td><code>children: [...]</code> array</td>
          </tr>
          <tr>
            <td><strong>Lazy Loading</strong></td>
            <td>Load modules on-demand</td>
            <td>
              <code
                >{path: 'feature', loadChildren: () =>
                import('./student/student.module').then(m =>
                m.StudentModule)}</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Router Guards</strong></td>
            <td>Protect routes (auth, roles)</td>
            <td>
              <code>canActivate: [AuthGuard]</code>, <code>CanDeactivate</code>,
              <code>CanLoad</code>
            </td>
          </tr>
          <tr>
            <td><strong>Navigation</strong></td>
            <td>Template link or programmatic</td>
            <td>
              <code>&lt;a routerLink="/home"&gt;</code> or
              <code
                >this.router.navigate(['/search', userId], { queryParams: {
                name: 'Tim' } })</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Router Outlet</strong></td>
            <td>Placeholder where Angular renders the matched component</td>
            <td><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></td>
          </tr>
          <tr>
            <td><strong>Resolver</strong></td>
            <td>Load data before route activates</td>
            <td><code>resolve: {user: UserResolver}</code></td>
          </tr>
          <tr>
            <td><strong>Query Params</strong></td>
            <td>Optional URL data</td>
            <td>
              <code>?page=2&amp;sort=name</code> â€” read via
              <code>route.queryParams.subscribe()</code> or
              <code>route.snapshot.queryParamMap.get('page')</code>
            </td>
          </tr>
          <tr>
            <td><strong>Preload Strategy</strong></td>
            <td>Load lazy modules in background</td>
            <td>
              <code>NoPreload</code>, <code>PreloadAllModules</code>, Custom
              Preloading
            </td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 7 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 7: Forms <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>What it is</th>
            <th>Best for</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Template-Driven Form</strong></td>
            <td>HTML-based form using <code>ngModel</code></td>
            <td>Simple forms</td>
            <td>
              <code
                >&lt;form #userForm="ngForm"
                (ngSubmit)="submit(userForm)"&gt;</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Reactive Form</strong></td>
            <td>TypeScript-based form model</td>
            <td>Complex &amp; dynamic forms</td>
            <td><code>this.form = this.fb.group({...})</code></td>
          </tr>
          <tr>
            <td><strong>FormControl</strong></td>
            <td>Single form field</td>
            <td>One input</td>
            <td>
              <code
                >this.fb.control('', Validators.required, { updateOn: 'blur'
                })</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>FormGroup</strong></td>
            <td>Group of controls</td>
            <td>Related fields</td>
            <td>
              <code
                >this.fb.group({ email: ['', [Validators.required,
                Validators.email]] })</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>FormArray</strong></td>
            <td>Dynamic list of controls</td>
            <td>Add/remove rows</td>
            <td><code>this.fb.array([])</code></td>
          </tr>
          <tr>
            <td><strong>Read Error</strong></td>
            <td>Check invalid, touched, error state</td>
            <td>Template error display</td>
            <td>
              <code
                >*ngIf="u.invalid &amp;&amp; u.touched &amp;&amp;
                u.errors?.['required']"</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Custom Validator</strong></td>
            <td>
              User-defined validation; Directive, Sync, Async, Cross-field
            </td>
            <td>Business rules</td>
            <td>
              <code>(control: AbstractControl): ValidationErrors | null</code>
            </td>
          </tr>
          <tr>
            <td><strong>PatchValue vs SetValue</strong></td>
            <td>Update form values</td>
            <td>Partial vs full update</td>
            <td><code>patchValue()</code> / <code>setValue()</code></td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 8 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 8: HTTP &amp; API Communication <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>HttpClient Service:</strong> Makes HTTP requests â€”
          <code>http.get&lt;User[]&gt;('/api/users')</code>,
          <code>http.post('/api/users', data)</code>; all methods return
          Observables
        </li>
        <li>
          <strong>Request Options:</strong> <code>responseType</code> (json,
          text, blob), <code>observe</code> (body, response, events),
          <code>headers</code>, <code>params</code>, <code>reportProgress</code>
        </li>
        <li>
          <strong>Interceptors:</strong> Middleware for auth tokens, error
          handling, logs, loading states â€”
          <code>intercept(req, next) { return next.handle(req); }</code>
        </li>
        <li>
          <strong>Error Handling:</strong> Use <code>catchError</code> operator
          â€”
          <code>catchError(error => { return throwError(() => error); })</code>
        </li>
        <li>
          <strong>Loading States:</strong> Track request progress for UI
          feedback (spinners, progress bars)
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 9 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 9: RxJS <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>RxJS:</strong> Provides Observables for handling streams of
          async data over time â€” with operators to transform data, subscriptions
          to listen, and the ability to cancel. Unlike Promises (single value,
          eager, not cancellable)
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>What it is</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Observable</strong></td>
            <td>Emits stream of data over time</td>
            <td>
              <code
                >new Observable(observer => { observer.next(1);
                observer.complete(); })</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Subscription</strong></td>
            <td>Listen to Observable; must unsubscribe</td>
            <td>
              <code
                >obs.subscribe({ next: v => {}, error: e => {}, complete: () =>
                {} })</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Subject</strong></td>
            <td>
              Observable + Observer; emit and receive values; no stored value
            </td>
            <td><code>subject.next(value)</code></td>
          </tr>
          <tr>
            <td><strong>BehaviorSubject</strong></td>
            <td>
              Stores latest value; emits it immediately to new subscribers
            </td>
            <td><code>new BehaviorSubject(initialValue)</code></td>
          </tr>
          <tr>
            <td><strong>ReplaySubject</strong></td>
            <td>Replays N previously emitted values to new subscribers</td>
            <td><code>new ReplaySubject(2)</code></td>
          </tr>
          <tr>
            <td><strong>AsyncSubject</strong></td>
            <td>Emits only the last value when observable completes</td>
            <td><code>new AsyncSubject()</code></td>
          </tr>
          <tr>
            <td><strong>pipe()</strong></td>
            <td>Chain operators</td>
            <td><code>obs.pipe(map(x => x * 2), filter(x => x > 5))</code></td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p>
          <strong>RxJS Operators:</strong> Functions that transform, filter,
          combine, or control Observable stream data
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Operator</th>
            <th>What it does</th>
            <th>Where to use</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>map</strong></td>
            <td>Transform value</td>
            <td>Convert API response to needed shape</td>
            <td><code>pipe(map(u => u.name))</code></td>
          </tr>
          <tr>
            <td><strong>filter</strong></td>
            <td>Allow matching values only</td>
            <td>Skip inactive users</td>
            <td><code>pipe(filter(u => u.active))</code></td>
          </tr>
          <tr>
            <td><strong>switchMap</strong></td>
            <td>Cancel previous &amp; start new inner observable</td>
            <td>Search API on typing</td>
            <td><code>pipe(switchMap(t => api(t)))</code></td>
          </tr>
          <tr>
            <td><strong>catchError</strong></td>
            <td>Handle errors gracefully</td>
            <td>Fallback when API fails</td>
            <td><code>pipe(catchError(() => of([])))</code></td>
          </tr>
          <tr>
            <td><strong>debounceTime</strong></td>
            <td>Wait before emitting</td>
            <td>Emit after user stops typing</td>
            <td><code>pipe(debounceTime(300))</code></td>
          </tr>
          <tr>
            <td><strong>distinctUntilChanged</strong></td>
            <td>Skip duplicate consecutive values</td>
            <td>Avoid same API call twice</td>
            <td><code>pipe(distinctUntilChanged())</code></td>
          </tr>
          <tr>
            <td><strong>takeUntil</strong></td>
            <td>Auto-unsubscribe when signal emits</td>
            <td>Component destroy cleanup</td>
            <td><code>pipe(takeUntil(destroy$))</code></td>
          </tr>
          <tr>
            <td><strong>combineLatest</strong></td>
            <td>Combine latest values of multiple observables</td>
            <td>Multiple filters together</td>
            <td><code>combineLatest([api1$, api2$])</code></td>
          </tr>
          <tr>
            <td><strong>forkJoin</strong></td>
            <td>Wait for all to complete then emit all final results</td>
            <td>Load page initial data in parallel</td>
            <td><code>forkJoin([api1$, api2$])</code></td>
          </tr>
          <tr>
            <td><strong>shareReplay</strong></td>
            <td>Cache and share result across subscribers</td>
            <td>Avoid repeated HTTP calls</td>
            <td><code>pipe(shareReplay(1))</code></td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 10 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 10: Signals (Angular 16+) <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Signals:</strong> New reactive primitive variables for
          fine-grained reactivity; alternative to RxJS for local state;
          auto-updates UI.
          <strong
            >Signals = simple UI state; RxJS = async and complex data
            streams.</strong
          >
        </p>
      </div>

      <ul>
        <li>
          <strong>signal():</strong> Create reactive variable â€”
          <code>count = signal(0);</code> then <code>{{count()}}</code> in
          template
        </li>
        <li>
          <strong>computed():</strong> Derived readonly value that
          auto-recalculates â€”
          <code>double = computed(() => this.count() * 2);</code>
        </li>
        <li>
          <strong>effect():</strong> Function that automatically runs when
          signals change â€”
          <code>effect(() => { console.log(this.count()); });</code>
        </li>
        <li>
          <strong>Methods:</strong> <code>signal.set(5)</code> replace,
          <code>signal.update(v => v + 1)</code> transform
        </li>
        <li>
          <strong>Signal Inputs/Outputs:</strong> Replace
          <code>@Input()</code> / <code>@Output()</code> â€”
          <code>name = input&lt;string&gt;()</code>,
          <code>count = model&lt;number&gt;(0)</code>
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 11 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 11: Pipes <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Pipes:</strong> Transform or format data in templates before
          displaying without modifying the underlying data
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Pipe</th>
            <th>What it does</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>date</strong></td>
            <td>Format dates</td>
            <td><code>{{today | date:'short'}}</code></td>
          </tr>
          <tr>
            <td><strong>currency</strong></td>
            <td>Format money</td>
            <td><code>{{price | currency:'USD'}}</code></td>
          </tr>
          <tr>
            <td><strong>async</strong></td>
            <td>Unwrap Observables/Promises; auto-unsubscribes</td>
            <td><code>{{data$ | async as newVariable}}</code></td>
          </tr>
          <tr>
            <td><strong>uppercase / lowercase</strong></td>
            <td>Convert case</td>
            <td><code>{{name | uppercase}}</code></td>
          </tr>
          <tr>
            <td><strong>json</strong></td>
            <td>Debug objects</td>
            <td><code>{{obj | json}}</code></td>
          </tr>
          <tr>
            <td><strong>slice</strong></td>
            <td>Extract portion of array/string</td>
            <td><code>{{items | slice:0:5}}</code></td>
          </tr>
          <tr>
            <td><strong>Custom Pipe</strong></td>
            <td>User-defined transformation</td>
            <td>
              <code>@Pipe({name: 'filter'})</code> with <code>transform()</code>
            </td>
          </tr>
          <tr>
            <td><strong>Pure vs Impure</strong></td>
            <td>Pure (default) runs only when input reference changes</td>
            <td>Impure runs on every change detection cycle (slower)</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 12 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 12: State Management &amp; Data Passing
      <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>State Management Ways:</strong> Component state, Shared
          Service with RxJS (Subjects), Signals, NgRx (Store), Router state,
          Browser storage.
        </p>
        <p>
          <strong>NgRx:</strong> Action triggers effect â†’ effect calls API â†’
          success/error â†’ reducer updates store â†’ selectors give data â†’ UI
          updates automatically.
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Direction</th>
            <th>Techniques</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Component â†’ Template</strong></td>
            <td>Interpolation, Property Binding</td>
            <td><code>{{value}}</code>, <code>[prop]="value"</code></td>
          </tr>
          <tr>
            <td><strong>Template â†’ Component</strong></td>
            <td>Template variables, Event binding, Forms, Two-way Binding</td>
            <td>
              <code>(click)="fn(f.value)"</code>,
              <code>[(ngModel)]="value"</code>
            </td>
          </tr>
          <tr>
            <td><strong>Component â†” Component</strong></td>
            <td>@Input / @Output, Shared Service + RxJS Subject, Router</td>
            <td>
              <code>@Input() data</code>,
              <code>@Output() event = new EventEmitter()</code>
            </td>
          </tr>
          <tr>
            <td><strong>App State</strong></td>
            <td>Service, Signals, NgRx</td>
            <td>BehaviorSubject, signal(), Store</td>
          </tr>
          <tr>
            <td><strong>Route â†’ Component</strong></td>
            <td>Route/Query Parameters, Route Data, Resolver</td>
            <td>Pass URL values, preload data</td>
          </tr>
          <tr>
            <td><strong>Browser Storage</strong></td>
            <td>Persist state across reloads or sessions</td>
            <td>
              <code>localStorage</code>, <code>sessionStorage</code>,
              <code>cookie</code>
            </td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 13 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 13: Change Detection <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>Change Detection:</strong> Angular watches for data changes
          and updates the view.
          <strong
            >Use OnPush with signals, observables, async pipe, or manual
            methods.</strong
          >
        </p>
      </div>

      <ul>
        <li>
          <strong>Default Strategy:</strong> Angular uses
          <code>Zone.js</code> to check the entire component tree on every event
          (click, HTTP, timer). Causes unnecessary checks and slow performance
          on large apps.
        </li>
        <li>
          <strong>OnPush Strategy:</strong> Checks component only when @Input
          reference changes, component event occurs, async/observable emits, or
          CD is manually triggered. Much more performant.
        </li>
        <li>
          <strong>ChangeDetectorRef:</strong> Manual control â€”
          <code>markForCheck()</code> (check next cycle),
          <code>detectChanges()</code> (run immediately),
          <code>detach()</code> (stop checking), <code>attach()</code> (resume)
        </li>
        <li>
          <strong>When to use:</strong> Use <code>OnPush</code> + manual
          detection for large lists, complex UIs, or frequently updating
          components
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 14 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 14: Authentication &amp; Guards <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>Purpose</th>
            <th>Implementation</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>AuthService</strong></td>
            <td>Handle login, store token, check auth</td>
            <td><code>login(creds) { return http.post(...) }</code></td>
          </tr>
          <tr>
            <td><strong>Token Storage</strong></td>
            <td>Store JWT after login</td>
            <td>
              <code>localStorage.setItem('token', jwt)</code> or HttpOnly cookie
            </td>
          </tr>
          <tr>
            <td><strong>AuthGuard</strong></td>
            <td>
              Protect routes from unauthorized access; check auth and roles
            </td>
            <td>
              <code
                >canActivate(): boolean { return this.authService.isLoggedIn();
                }</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Interceptor</strong></td>
            <td>Auto-attach token to every outgoing request</td>
            <td>
              <code
                >req.clone({setHeaders: {'Authorization': 'Bearer ' +
                token}})</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Error Handling</strong></td>
            <td>Redirect on 401/403 responses</td>
            <td>
              <code>if (error.status === 401) router.navigate(['/login'])</code>
            </td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 15 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 15: Performance &amp; Best Practices
      <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>Why / Benefit</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>OnPush Change Detection</strong></td>
            <td>Reduce unnecessary checks</td>
            <td>
              <code>changeDetection: ChangeDetectionStrategy.OnPush</code>
            </td>
          </tr>
          <tr>
            <td><strong>Lazy Loading</strong></td>
            <td>Load feature only when needed</td>
            <td>
              <code
                >loadChildren: () => import('./feature/feature.module')</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>Preloading Strategy</strong></td>
            <td>Load lazy modules silently in background after app starts</td>
            <td><code>PreloadAllModules</code></td>
          </tr>
          <tr>
            <td><strong>trackBy in ngFor</strong></td>
            <td>Prevent unnecessary DOM re-renders on list changes</td>
            <td><code>*ngFor="let i of items; trackBy: trackById"</code></td>
          </tr>
          <tr>
            <td><strong>Virtual Scrolling</strong></td>
            <td>Render only visible items in large lists</td>
            <td><code>&lt;cdk-virtual-scroll-viewport&gt;</code></td>
          </tr>
          <tr>
            <td><strong>Build Optimization</strong></td>
            <td>
              AOT, tree shaking, minification â€” faster &amp; smaller build
            </td>
            <td><code>ng build --configuration production</code></td>
          </tr>
          <tr>
            <td><strong>Avoid Functions in Template</strong></td>
            <td>Functions re-run on every change detection cycle</td>
            <td>Use component properties instead</td>
          </tr>
          <tr>
            <td><strong>Unsubscribe Pattern</strong></td>
            <td>Prevent memory leaks from forgotten subscriptions</td>
            <td><code>takeUntil(destroy$)</code> or <code>async</code> pipe</td>
          </tr>
          <tr>
            <td><strong>shareReplay</strong></td>
            <td>Cache HTTP response; avoid duplicate calls</td>
            <td><code>pipe(shareReplay(1))</code></td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>Clean Architecture:</strong></p>
        <ul>
          <li>
            <strong>Repository Layer:</strong> Pure data access (HTTP); calls
            DB, external APIs
          </li>
          <li>
            <strong>Service Layer:</strong> Business logic, API orchestration;
            calls repository
          </li>
          <li>
            <strong>Facade Layer:</strong> Coordinates state, services, NgRx;
            hides complexity; calls services/state
          </li>
          <li>
            <strong>Component Layer:</strong> UI only, no business logic; calls
            Facade
          </li>
        </ul>
      </div>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 16 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 16: Testing <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Tool / Concept</th>
            <th>Purpose</th>
            <th>Syntax</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Jasmine</strong></td>
            <td>Testing framework</td>
            <td>
              <code>describe('Test', () => { it('works', () => {...}) })</code>
            </td>
          </tr>
          <tr>
            <td><strong>TestBed</strong></td>
            <td>Setup testing module</td>
            <td>
              <code
                >TestBed.configureTestingModule({declarations: [Comp]})</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>ComponentFixture</strong></td>
            <td>Wrapper for component in tests</td>
            <td><code>fixture = TestBed.createComponent(Comp)</code></td>
          </tr>
          <tr>
            <td><strong>spyOn()</strong></td>
            <td>Mock service methods</td>
            <td>
              <code>spyOn(service, 'getData').and.returnValue(of([]))</code>
            </td>
          </tr>
          <tr>
            <td><strong>detectChanges()</strong></td>
            <td>Trigger change detection in tests</td>
            <td><code>fixture.detectChanges()</code></td>
          </tr>
          <tr>
            <td><strong>HttpTestingController</strong></td>
            <td>Mock HTTP requests</td>
            <td><code>httpMock.expectOne('/api/users')</code></td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 17 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 17: App Flow &amp; CLI Commands <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>File</th>
            <th>Purpose</th>
            <th>Key Points</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>angular.json</strong> <small>(Step 0)</small></td>
            <td>CLI build &amp; workspace config</td>
            <td>
              Defines entry point (<code>main.ts</code>), output paths, assets,
              styles â€” <strong>first file read on <code>ng serve</code></strong>
            </td>
          </tr>
          <tr>
            <td><strong>main.ts</strong> <small>(Step 1)</small></td>
            <td>Application entry point</td>
            <td>
              Calls <code>bootstrapApplication(AppComponent, appConfig)</code> â€”
              <strong>first file executed</strong>
            </td>
          </tr>
          <tr>
            <td><strong>app.config.ts</strong> <small>(Step 2)</small></td>
            <td>App-level DI &amp; configuration</td>
            <td>
              Registers <code>providers[]</code> (router, HTTP, animations);
              imports <code>app.routes.ts</code>
            </td>
          </tr>
          <tr>
            <td><strong>app.routes.ts</strong> <small>(Step 3)</small></td>
            <td>Route definitions</td>
            <td>
              <code>Routes[]</code> pathâ€“component mapping via
              <code>provideRouter(routes)</code>
            </td>
          </tr>
          <tr>
            <td><strong>index.html</strong> <small>(Step 4)</small></td>
            <td>HTML shell loaded by browser</td>
            <td>
              Contains <code>&lt;app-root&gt;</code>; Angular replaces it with
              rendered AppComponent
            </td>
          </tr>
          <tr>
            <td><strong>app.component.ts</strong> <small>(Step 5)</small></td>
            <td>Root application component</td>
            <td>
              <code>selector: 'app-root'</code>; hosts
              <code>&lt;router-outlet&gt;</code>
            </td>
          </tr>
          <tr>
            <td><strong>Child Components</strong> <small>(Step 6)</small></td>
            <td>Route-based UI components</td>
            <td>
              Loaded dynamically inside <code>&lt;router-outlet&gt;</code> based
              on active route
            </td>
          </tr>
          <tr>
            <td><strong>Services</strong> <small>(Step 7)</small></td>
            <td>Business logic &amp; data layer</td>
            <td>
              Lazy-loaded via DI; handles HTTP, state, shared logic, component
              communication
            </td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>Angular CLI:</strong></p>
        <ul>
          <li>
            <code>ng new projectName</code> â€” create project |
            <code>ng serve</code> â€” dev server (port 4200)
          </li>
          <li>
            <code>ng g c componentName</code> â€” component |
            <code>ng g s services/loggerService</code> â€” service in services
            folder
          </li>
          <li>
            <code>ng g d / p</code> â€” directive/pipe | <code>ng build</code> â€”
            production build
          </li>
          <li>
            <code>ng test</code> â€” run unit tests | <code>g</code> = generate,
            <code>c</code> = component, <code>s</code> = service
          </li>
        </ul>
      </div>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 18 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 18: Miscellaneous <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <ul>
        <li>
          <strong>Environments:</strong> Selected via CLI â€”
          <code>ng build --configuration=production</code>;
          <code>angular.json</code> defines how file replacement happens
        </li>
        <li>
          <strong>NgModules (Older):</strong> Groups related components,
          directives, pipes, services; consuming module must import the
          exporting module
        </li>
        <li>
          <strong>Standalone Components:</strong> <code>standalone: true</code>;
          import components/directives/pipes directly in <code>imports</code>;
          no NgModules needed â€” reduces boilerplate
        </li>
        <li>
          <strong>Error Handling:</strong> Template <code>city?.name</code>,
          component <code>try-catch</code>, service/HTTP
          <code>catchError</code>, global error handler via
          <code>ErrorHandler</code> interface
        </li>
        <li>
          <strong>Memory Leaks:</strong> Caused by uncleaned subscriptions,
          timers, event listeners, global references, and missing
          <code>ngOnDestroy</code> cleanup
        </li>
        <li>
          <strong>Browser Storage:</strong> <code>localStorage</code> â€”
          tokens/UI state; persists until cleared; <code>sessionStorage</code> â€”
          temporary; clears on browser close; <code>cookies</code> â€” auth
          tokens; sent with HTTP requests; expire based on config
        </li>
      </ul>
      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          ðŸ“·
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 19: SCENARIOS ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 19: Scenario-Based Questions <span class="toggle-icon">â–¼</span>
    </h2>
    <div class="section-content">
      <div class="scenario-item">
        <h3>1. Memory Leak from Unsubscribed Observables</h3>
        <p>
          App memory grows steadily. After navigating between components for a
          while, the browser becomes slow. Investigation shows HTTP
          subscriptions are never cleaned up. How do you fix it?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Every <code>subscribe()</code> call that is never unsubscribed keeps
            the Observable alive even after the component is destroyed. Fix: use
            <code>takeUntil(destroy$)</code> with a <code>Subject</code> that
            emits in <code>ngOnDestroy</code>, or use the
            <code>async</code> pipe which auto-unsubscribes. For single-value
            HTTP calls, <code>take(1)</code> works too. Verify using Chrome
            DevTools Memory tab â€” heap snapshots should not show growing
            component instances.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>2. Search Box Fires API on Every Keystroke</h3>
        <p>
          Typing "Angular" in a search box fires 7 separate API calls â€” one per
          character. Old results from slower requests sometimes appear after
          newer ones. How do you fix both problems?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Two issues â€” excessive calls and race conditions. Fix both with RxJS
            operators on the input's <code>valueChanges</code>:
            <code>debounceTime(300)</code> waits until the user stops typing,
            <code>distinctUntilChanged()</code> skips if the value hasn't
            changed, and <code>switchMap()</code> cancels the previous in-flight
            request and starts a fresh one. With <code>switchMap</code>, only
            the latest request's result ever reaches the UI â€” race condition
            eliminated.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>3. Page Freezes on Every Interaction with Large List</h3>
        <p>
          A product list with 1000 items freezes for 2â€“3 seconds on every button
          click or keystroke. Angular is re-checking the entire tree each time.
          How do you fix the performance?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Default change detection checks every component on every event. Fix:
            switch the list component to
            <code>ChangeDetectionStrategy.OnPush</code> â€” Angular only re-checks
            it when an @Input reference changes, an event fires, or an
            Observable emits. Also add <code>trackBy</code> to
            <code>*ngFor</code> so Angular reuses DOM nodes instead of
            recreating the full list. For very large lists, use
            <code>cdk-virtual-scroll-viewport</code> to render only visible
            rows.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>4. OnPush Component Doesn't Update When Nested Object Mutates</h3>
        <p>
          You set <code>ChangeDetectionStrategy.OnPush</code> for performance.
          You update <code>user.address.city = 'New York'</code> but the UI
          doesn't reflect the change. Why?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            OnPush only triggers when the <strong>reference</strong> changes.
            Mutating a nested property keeps the same object reference â€” Angular
            sees no change. Fix: always create a new object reference â€”
            <code
              >this.user = {...this.user, address: {...this.user.address, city:
              'New York'}}</code
            >. This immutable update creates a new reference, which OnPush
            detects. Alternatively, call <code>cdr.markForCheck()</code> to
            manually signal Angular to re-check that component.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>5. 5 Components All Call the Same API on Load</h3>
        <p>
          Your dashboard loads 5 components and each independently calls
          <code>getUserProfile()</code>. You see 5 identical network requests
          fire simultaneously. How do you prevent duplicate calls?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Each <code>subscribe()</code> triggers the Observable from scratch â€”
            so 5 subscribers = 5 HTTP calls. Fix: add
            <code>shareReplay(1)</code> in the service â€”
            <code>return this.http.get('/api/user').pipe(shareReplay(1));</code
            >. The first subscriber fires the request; all others get the cached
            response. The result is stored and replayed to any late subscribers.
            One network call for the whole dashboard.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>6. @ViewChild Returns Undefined in ngOnInit</h3>
        <p>
          You access a child element with
          <code>@ViewChild('inputElement') myInput</code> in
          <code>ngOnInit()</code> but it's undefined. The element clearly exists
          in the template. Why?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            <code>@ViewChild</code> is only populated after the view is fully
            rendered â€” <code>ngOnInit</code> runs before that. Use
            <code>ngAfterViewInit()</code> instead, which runs after the view is
            ready. For elements that are always present (no <code>*ngIf</code>),
            you can use
            <code>@ViewChild('inputElement', {static: true})</code> which makes
            it available in <code>ngOnInit</code>. Similarly,
            <code>@ContentChild</code> requires
            <code>ngAfterContentInit()</code>.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>7. Child Component Ignores Updated @Input</h3>
        <p>
          You pass data from parent to child via <code>@Input</code>. When the
          parent updates the data, the child still shows the old value because
          it processed the input only in <code>ngOnInit</code>. How do you fix
          it?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            <code>ngOnInit</code> runs once â€” it doesn't react to subsequent
            <code>@Input</code> changes. Use
            <code>ngOnChanges(changes: SimpleChanges)</code> which Angular calls
            every time an @Input value changes, or use an
            <code>@Input</code> setter which runs automatically on every new
            value. Both ensure the child always stays in sync with whatever the
            parent provides.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>8. Navigating to /user/2 from /user/1 Shows Wrong Data</h3>
        <p>
          On a user detail page (<code>/user/:id</code>), navigating from user 1
          to user 2 doesn't refresh the data. Angular reuses the same component
          and <code>ngOnInit</code> doesn't run again. How do you fix it?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            When the same component handles a route change (same component,
            different params), Angular doesn't destroy and recreate it â€” so
            <code>ngOnInit</code> won't fire. Fix: subscribe to
            <code>ActivatedRoute.paramMap</code> observable instead of using
            <code>snapshot</code>. Whenever the route param changes, the
            observable emits the new value and you reload data accordingly. Use
            <code>switchMap</code> to cancel the previous request if navigation
            happens quickly.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>9. JWT Expires During Active Session â€” API Returns 401</h3>
        <p>
          Users are actively working when their JWT access token expires. All
          subsequent API calls fail with 401. Users lose their work and get
          redirected to login. How do you handle this gracefully?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Use an HTTP interceptor to catch 401 responses. When a 401 is
            received, the interceptor calls the refresh token endpoint to get a
            new access token, stores it, and retries the original failed request
            automatically â€” the user never knows anything happened. If the
            refresh token is also expired, redirect to login. Use a flag to
            prevent multiple simultaneous refresh calls when several requests
            fail at once.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>10. App Initial Load Takes 15 Seconds â€” 10MB Bundle</h3>
        <p>
          The app takes 15 seconds to load on first visit. The entire JavaScript
          bundle is 10MB and downloaded upfront. Users on slow connections see a
          blank screen. How do you reduce this?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            The entire app is bundled into one file â€” the browser must download
            and parse all of it before rendering anything. Fix: implement
            <strong>lazy loading</strong> â€” routes load their feature modules
            only when the user navigates to them. Set a
            <strong>preloading strategy</strong> (e.g.
            <code>PreloadAllModules</code>) to silently load other modules in
            the background after the initial load. Build with
            <code>ng build --configuration production</code> for AOT
            compilation, tree shaking, and minification. Show a skeleton/spinner
            so users see something immediately.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>11. User Loses Form Data on Accidental Navigation</h3>
        <p>
          A user fills out a long registration form and accidentally clicks the
          browser back button or a link â€” all data is lost. How do you warn
          users about unsaved changes?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Use two mechanisms together: (1)
            <strong>CanDeactivate guard</strong> â€” intercepts Angular route
            navigation (links, <code>router.navigate()</code>) and shows a
            confirm dialog if the form is dirty. (2)
            <strong><code>@HostListener('window:beforeunload')</code></strong> â€”
            catches browser-level navigation (browser back button, tab close,
            refresh). Both together cover every exit path. Check
            <code>form.dirty</code> to only warn when changes were actually
            made.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>12. ExpressionChangedAfterItHasBeenCheckedError</h3>
        <p>
          The console shows "ExpressionChangedAfterItHasBeenCheckedError." A
          value bound in the template is being changed during or after change
          detection. How do you fix it?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Angular runs change detection then verifies values haven't changed â€”
            if they have, it throws this error (dev mode only). Cause: you're
            modifying a bound value inside <code>ngAfterViewChecked</code> or a
            lifecycle hook that runs during/after CD. Fix: move the update to
            <code>ngOnInit</code> if possible, or wrap it in
            <code>setTimeout(() => { ... }, 0)</code> to defer it to the next
            change detection cycle. Alternatively, use
            <code>ChangeDetectorRef.detectChanges()</code> after the update.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>

      <div class="scenario-item">
        <h3>13. Auth State Lost on Page Refresh</h3>
        <p>
          Users log in and can access protected routes. But refreshing the
          browser logs them out and redirects them to the login page. How do you
          persist auth state across refreshes?
        </p>
        <div class="answer">
          <strong>Answer:</strong>
          <p>
            Angular services are in memory â€” they reset on every page refresh.
            Fix: store the JWT in <code>localStorage</code> (or an HttpOnly
            cookie for better security). On app startup, read the stored token
            in the service and restore the auth state â€”
            <code>isLoggedIn$</code> BehaviorSubject gets the correct initial
            value. Route guards then check this state and allow or block access
            correctly. If using HttpOnly cookies, the browser sends the token
            automatically with every request without any manual restoration
            needed.
          </p>
        </div>
        <div class="image-icons">
          <span class="image-icons-label">Images:</span>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
          <button class="image-icon" onclick="toggleImage(this)" data-src="">
            ðŸ“·
          </button>
        </div>
        <div class="image-preview-box"></div>
      </div>
    </div>
    <!-- end section-content scenarios -->

    <script src="../change.js"></script>
  </body>
</html>
