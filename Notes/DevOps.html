<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style.css" />
    <title>DevOps Notes</title>
  </head>
  <body>
    <h1>9. DevOps: Git, CI/CD, Docker &amp; Kubernetes</h1>

    <!-- ===================== SECTION 1 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 1: Git Essentials <span class="toggle-icon">‚ñº</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Command</th>
            <th>What it does</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>git clone</strong></td>
            <td>Download entire project from server to your computer</td>
            <td><code>git clone https://repo-url</code></td>
          </tr>
          <tr>
            <td><strong>git status</strong></td>
            <td>Check what files changed since last commit</td>
            <td><code>git status</code></td>
          </tr>
          <tr>
            <td><strong>git add</strong></td>
            <td>Stage changed files to be committed (pack the box)</td>
            <td><code>git add .</code></td>
          </tr>
          <tr>
            <td><strong>git commit</strong></td>
            <td>Save staged changes with a message (seal the box)</td>
            <td><code>git commit -m "Fixed bug X"</code></td>
          </tr>
          <tr>
            <td><strong>git push</strong></td>
            <td>Send committed changes to server (mail the box)</td>
            <td><code>git push origin main</code></td>
          </tr>
          <tr>
            <td><strong>git pull</strong></td>
            <td>Download latest changes from server</td>
            <td><code>git pull origin main</code></td>
          </tr>
          <tr>
            <td><strong>git branch</strong></td>
            <td>Create separate workspace for a feature</td>
            <td><code>git branch feature-login</code></td>
          </tr>
          <tr>
            <td><strong>git checkout</strong></td>
            <td>Switch between branches</td>
            <td><code>git checkout feature-login</code></td>
          </tr>
          <tr>
            <td><strong>git merge</strong></td>
            <td>Combine changes from one branch into another</td>
            <td><code>git merge feature-login</code></td>
          </tr>
          <tr>
            <td><strong>Merge Conflicts</strong></td>
            <td>
              Same file changed in both branches ‚Äî must resolve manually by
              choosing which version to keep
            </td>
            <td>Edit file ‚Üí save ‚Üí <code>git add .</code> ‚Üí commit</td>
          </tr>
          <tr>
            <td><strong>.gitignore</strong></td>
            <td>
              Tell Git to ignore specific files ‚Äî node_modules, secrets, build
              output
            </td>
            <td><code>.env, *.log, bin/, obj/</code></td>
          </tr>
          <tr>
            <td><strong>Pull Request (PR)</strong></td>
            <td>
              Ask team to review your branch before merging ‚Äî quality check
              before code enters main
            </td>
            <td>GitHub / Azure DevOps PR interface</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 2 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 2: CI/CD Pipeline <span class="toggle-icon">‚ñº</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Term</th>
            <th>Meaning</th>
            <th>Why important</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>CI ‚Äî Continuous Integration</strong></td>
            <td>
              Every push auto-compiles and runs tests. Instant feedback if
              something breaks.
            </td>
            <td>Catch bugs early, not in production</td>
          </tr>
          <tr>
            <td><strong>CD ‚Äî Continuous Deployment</strong></td>
            <td>
              After tests pass, code automatically goes to production ‚Äî no
              manual steps.
            </td>
            <td>Deploy instantly, no manual intervention</td>
          </tr>
          <tr>
            <td><strong>CR ‚Äî Continuous Release</strong></td>
            <td>
              Code is always ready to deploy, but a human must approve before
              going live.
            </td>
            <td>You control when changes reach users</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>CI/CD Pipeline ‚Äî Step-by-Step Flow:</strong></p>
        <ol>
          <li>
            <strong>Developer pushes code</strong> ‚Äî
            <code>git push origin main</code>
          </li>
          <li>
            <strong>Pipeline triggers automatically</strong> ‚Äî Git push
            detected, Azure DevOps starts pipeline with no manual action
          </li>
          <li>
            <strong>Build phase</strong> ‚Äî <code>dotnet build</code> ‚Äî if
            compile error, pipeline stops and you get an alert
          </li>
          <li>
            <strong>Test phase</strong> ‚Äî <code>dotnet test</code> ‚Äî if any test
            fails, pipeline stops before deployment
          </li>
          <li>
            <strong>Build Docker image</strong> ‚Äî pipeline reads Dockerfile,
            creates a snapshot of your compiled app
          </li>
          <li>
            <strong>Push to Container Registry (ACR)</strong> ‚Äî image tagged
            with version (<code>myapi:v1.2.3</code>) and stored in ACR
          </li>
          <li>
            <strong>Deploy to Dev</strong> ‚Äî image deployed to Dev environment
            automatically
          </li>
          <li>
            <strong>Approval gate</strong> ‚Äî pipeline pauses, waits for human
            approval before Staging/Production
          </li>
          <li>
            <strong>Deploy to Staging ‚Üí Production</strong> ‚Äî after approval,
            same image deployed to each environment
          </li>
          <li>
            <strong>App is live</strong> ‚Äî container running, monitoring
            watching for errors
          </li>
        </ol>
      </div>

      <table>
        <thead>
          <tr>
            <th>YAML Section</th>
            <th>What it does</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>trigger</strong></td>
            <td>When does pipeline run? (every push, only on PR, scheduled)</td>
            <td><code>trigger: - main</code></td>
          </tr>
          <tr>
            <td><strong>pool</strong></td>
            <td>Which machine runs the pipeline</td>
            <td><code>vmImage: 'ubuntu-latest'</code></td>
          </tr>
          <tr>
            <td><strong>variables</strong></td>
            <td>Store values reused across pipeline</td>
            <td><code>buildConfiguration: 'Release'</code></td>
          </tr>
          <tr>
            <td><strong>stages</strong></td>
            <td>Divide pipeline into logical phases</td>
            <td>Build ‚Üí Test ‚Üí Deploy</td>
          </tr>
          <tr>
            <td><strong>jobs</strong></td>
            <td>Tasks inside each stage that run in order</td>
            <td>Compile, Test, Build Docker, Push to ACR</td>
          </tr>
          <tr>
            <td><strong>steps</strong></td>
            <td>Individual commands to execute</td>
            <td>
              <code>dotnet build</code>, <code>dotnet test</code>,
              <code>docker build</code>
            </td>
          </tr>
        </tbody>
      </table>

      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>What it means</th>
            <th>Why it matters</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Artifacts</strong></td>
            <td>
              Output from build (compiled .exe, Docker image) that gets deployed
            </td>
            <td>The actual thing deployed to production</td>
          </tr>
          <tr>
            <td><strong>Build Number</strong></td>
            <td>Each pipeline run gets a unique number (Build #123)</td>
            <td>Track exactly which code version is running in prod</td>
          </tr>
          <tr>
            <td><strong>Build Failure</strong></td>
            <td>Pipeline stops if code doesn't compile or tests fail</td>
            <td>Bad code never reaches production</td>
          </tr>
          <tr>
            <td><strong>Deployment Approval</strong></td>
            <td>Pipeline pauses at Staging/Production for human sign-off</td>
            <td>You control when code goes live</td>
          </tr>
          <tr>
            <td><strong>Rollback</strong></td>
            <td>
              If new deployment breaks prod, redeploy the previous working
              version
            </td>
            <td>Fast recovery with minimal damage</td>
          </tr>
          <tr>
            <td><strong>Secrets Management</strong></td>
            <td>Passwords and API keys stored in Key Vault ‚Äî never in code</td>
            <td>Prevents security breaches</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 3 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 3: Docker <span class="toggle-icon">‚ñº</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Problem</th>
            <th>Without Docker</th>
            <th>With Docker</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Different environments</strong></td>
            <td>
              Works on your PC, breaks on server (different OS, libraries)
            </td>
            <td>Same image works everywhere ‚Äî Windows, Linux, Mac</td>
          </tr>
          <tr>
            <td><strong>Dependency issues</strong></td>
            <td>Missing .NET version, SQL driver ‚Üí runtime errors</td>
            <td>Everything bundled in the Docker image</td>
          </tr>
          <tr>
            <td><strong>Deployment</strong></td>
            <td>Manual install steps, lots of room for error</td>
            <td>One command: <code>docker run</code> deploys everything</td>
          </tr>
          <tr>
            <td><strong>Scaling</strong></td>
            <td>Running multiple copies is complicated</td>
            <td>Run same image multiple times, load balance between them</td>
          </tr>
        </tbody>
      </table>

      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>What it is</th>
            <th>Analogy</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Docker Image</strong></td>
            <td>Blueprint of your app with all dependencies baked in</td>
            <td>A recipe</td>
          </tr>
          <tr>
            <td><strong>Docker Container</strong></td>
            <td>A running instance of an image</td>
            <td>The cooked dish from the recipe</td>
          </tr>
          <tr>
            <td><strong>Dockerfile</strong></td>
            <td>Text file with step-by-step instructions to build an image</td>
            <td>The recipe ingredients and steps</td>
          </tr>
          <tr>
            <td><strong>Docker Hub / Registry</strong></td>
            <td>
              Cloud storage for Docker images (like GitHub but for images)
            </td>
            <td>A library of recipes</td>
          </tr>
          <tr>
            <td><strong>Azure Container Registry (ACR)</strong></td>
            <td>Private company image storage ‚Äî your images are not public</td>
            <td>Your private recipe book</td>
          </tr>
          <tr>
            <td><strong>Volume</strong></td>
            <td>
              Persistent storage ‚Äî data survives even after container restarts
            </td>
            <td>A storage locker that outlives the container</td>
          </tr>
          <tr>
            <td><strong>Port Mapping</strong></td>
            <td>
              Connect container port to host port to expose app to outside
            </td>
            <td>
              <code>-p 5000:80</code> = host port 5000 maps to container port 80
            </td>
          </tr>
        </tbody>
      </table>

      <table>
        <thead>
          <tr>
            <th>Command</th>
            <th>What it does</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>docker build</strong></td>
            <td>Create image from Dockerfile</td>
            <td><code>docker build -t myapi:1.0 .</code></td>
          </tr>
          <tr>
            <td><strong>docker run</strong></td>
            <td>Create and start container from image</td>
            <td><code>docker run -d -p 5000:80 myapi:1.0</code></td>
          </tr>
          <tr>
            <td><strong>docker ps</strong></td>
            <td>List all running containers</td>
            <td><code>docker ps</code></td>
          </tr>
          <tr>
            <td><strong>docker stop</strong></td>
            <td>Stop a running container gracefully</td>
            <td><code>docker stop container-id</code></td>
          </tr>
          <tr>
            <td><strong>docker logs</strong></td>
            <td>View container output for debugging</td>
            <td><code>docker logs container-id</code></td>
          </tr>
          <tr>
            <td><strong>docker exec</strong></td>
            <td>Run a command inside a running container</td>
            <td><code>docker exec -it container-id bash</code></td>
          </tr>
          <tr>
            <td><strong>docker images</strong></td>
            <td>List all images on your computer</td>
            <td><code>docker images</code></td>
          </tr>
          <tr>
            <td><strong>docker push</strong></td>
            <td>Upload image to registry</td>
            <td><code>docker push acr.azurecr.io/myapi:1.0</code></td>
          </tr>
          <tr>
            <td><strong>docker pull</strong></td>
            <td>Download image from registry</td>
            <td><code>docker pull acr.azurecr.io/myapi:1.0</code></td>
          </tr>
          <tr>
            <td><strong>docker-compose up</strong></td>
            <td>Run multiple containers together (app + database)</td>
            <td><code>docker-compose up -d</code></td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>Dockerfile ‚Äî Line by Line:</strong></p>
        <pre>
FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build
# Start with .NET SDK image as base (has the compiler)
# "AS build" = name this stage "build" for multi-stage use

WORKDIR /src
# Set working directory inside container to /src

COPY . .
# Copy all files from your computer into /src in container

RUN dotnet publish -c Release -o /app
# Compile in Release mode; output goes to /app

FROM mcr.microsoft.com/dotnet/aspnet:7.0
# New stage ‚Äî lightweight runtime only (no compiler)
# Final image is much smaller than SDK image

WORKDIR /app

COPY --from=build /app .
# Copy only compiled output from the "build" stage

EXPOSE 80
# Container listens on port 80

ENTRYPOINT ["dotnet", "MyApp.dll"]
# Run this when container starts</pre
        >
      </div>

      <table>
        <thead>
          <tr>
            <th>Without Multi-Stage Build</th>
            <th>With Multi-Stage Build</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Final image includes SDK (~1 GB)</td>
            <td>Final image has runtime only (~200 MB) ‚Äî 5√ó smaller</td>
          </tr>
          <tr>
            <td>Includes compiler and build tools not needed at runtime</td>
            <td>Only what's needed to run the app</td>
          </tr>
          <tr>
            <td>Slower deployment, more storage cost</td>
            <td>Faster deployment, cheaper cloud storage</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>Docker Layer Caching:</strong></p>
        <ul>
          <li>
            <strong>Each Dockerfile line = one layer</strong> (filesystem
            snapshot)
          </li>
          <li>
            <strong>Unchanged layers are reused from cache</strong> ‚Äî builds in
            seconds instead of minutes
          </li>
          <li>
            <strong>Put frequently changing commands LAST</strong> ‚Äî copy source
            code after installing dependencies, so the install layer is cached
            and reused even when code changes
          </li>
          <li>
            <strong>Smaller image = faster everything</strong> ‚Äî less download
            time, faster deployments, lower storage cost
          </li>
        </ul>
      </div>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 4 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 4: Kubernetes (K8s) <span class="toggle-icon">‚ñº</span>
    </h2>
    <div class="section-content">
      <div class="note">
        <p>
          <strong>What is Kubernetes?</strong> Automatic manager for Docker
          containers. Handles running, scaling, updating, and healing containers
          across multiple machines. You declare what you want ‚Äî K8s figures out
          how to make it happen.
        </p>
        <ul>
          <li>
            <strong>Use K8s when:</strong> Many containers running across
            multiple servers at scale (like Netflix, Spotify)
          </li>
          <li>
            <strong>Don't use K8s when:</strong> 1‚Äì2 containers on a single
            machine ‚Äî just use Docker or App Service
          </li>
        </ul>
      </div>

      <table>
        <thead>
          <tr>
            <th>Component</th>
            <th>What it does</th>
            <th>Real-world example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Cluster</strong></td>
            <td>Group of machines (servers) running Kubernetes together</td>
            <td>10 servers in a data center = 1 K8s cluster</td>
          </tr>
          <tr>
            <td><strong>Node</strong></td>
            <td>
              Single machine/server inside the cluster that runs containers
            </td>
            <td>One physical or virtual server</td>
          </tr>
          <tr>
            <td><strong>Pod</strong></td>
            <td>Smallest K8s unit ‚Äî 1+ containers running together</td>
            <td>Usually 1 container per pod (your API)</td>
          </tr>
          <tr>
            <td><strong>Deployment</strong></td>
            <td>
              Instructions: "run 5 copies of my API, keep them running always"
            </td>
            <td>You declare 5 replicas ‚Üí K8s creates and manages them</td>
          </tr>
          <tr>
            <td><strong>Service</strong></td>
            <td>
              Load balancer in front of multiple pods ‚Äî single endpoint,
              balanced traffic
            </td>
            <td>5 API pods behind one URL ‚Äî traffic split between them</td>
          </tr>
          <tr>
            <td><strong>ReplicaSet</strong></td>
            <td>Ensures desired number of pods are always running</td>
            <td>
              1 pod crashes ‚Üí ReplicaSet creates a replacement immediately
            </td>
          </tr>
          <tr>
            <td><strong>ConfigMap</strong></td>
            <td>Store non-secret config (database URL, environment name)</td>
            <td>
              Dev vs Prod can have different DB URLs without rebuilding image
            </td>
          </tr>
          <tr>
            <td><strong>Secret</strong></td>
            <td>Store sensitive config (passwords, API keys) encrypted</td>
            <td>DB password injected at runtime ‚Äî never in code</td>
          </tr>
          <tr>
            <td><strong>Ingress</strong></td>
            <td>
              External HTTP entry point ‚Äî routes traffic to the right service
            </td>
            <td><code>api.example.com</code> ‚Üí routes to API service</td>
          </tr>
          <tr>
            <td><strong>Namespace</strong></td>
            <td>
              Logical isolation inside cluster ‚Äî separate dev, staging, prod
            </td>
            <td>Prevent accidents, easier management per environment</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>How Kubernetes Works ‚Äî Step-by-Step:</strong></p>
        <ol>
          <li>
            Write a <strong>Deployment YAML</strong> ‚Äî "run 5 replicas of
            myapi:1.0, listen on port 80"
          </li>
          <li>Apply it: <code>kubectl apply -f deployment.yaml</code></li>
          <li>
            K8s <strong>schedules pods</strong> across available nodes,
            distributing load evenly
          </li>
          <li>
            Each pod <strong>pulls the Docker image</strong> from ACR and starts
            the container
          </li>
          <li>
            A <strong>Service</strong> sits in front of all 5 pods ‚Äî single
            entry point, load balanced
          </li>
          <li>
            K8s <strong>continuously health-checks</strong> pods ‚Äî if one
            crashes, a new one is created automatically
          </li>
          <li>
            <strong>Scale up:</strong>
            <code>kubectl scale deployment myapi --replicas=10</code> ‚Üí 5 more
            pods instantly
          </li>
          <li>
            <strong>Rolling update:</strong> new image available ‚Üí K8s replaces
            pods one at a time ‚Üí zero downtime
          </li>
        </ol>
      </div>

      <div class="note">
        <p><strong>Basic Deployment YAML:</strong></p>
        <pre>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapi
spec:
  replicas: 5                        # Run 5 copies
  selector:
    matchLabels:
      app: myapi                     # Manage pods with this label
  template:
    metadata:
      labels:
        app: myapi
    spec:
      containers:
      - name: myapi
        image: acr.azurecr.io/myapi:1.0   # Always use specific tag, never "latest"
        ports:
        - containerPort: 80
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: db-url            # Config from ConfigMap, not hardcoded</pre
        >
      </div>

      <table>
        <thead>
          <tr>
            <th>Command</th>
            <th>What it does</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>kubectl apply</strong></td>
            <td>Create or update from YAML file</td>
            <td><code>kubectl apply -f deployment.yaml</code></td>
          </tr>
          <tr>
            <td><strong>kubectl get pods</strong></td>
            <td>List all running pods</td>
            <td><code>kubectl get pods -n default</code></td>
          </tr>
          <tr>
            <td><strong>kubectl get deployments</strong></td>
            <td>List all deployments</td>
            <td><code>kubectl get deployments</code></td>
          </tr>
          <tr>
            <td><strong>kubectl logs</strong></td>
            <td>View pod output for debugging</td>
            <td><code>kubectl logs myapi-pod-123</code></td>
          </tr>
          <tr>
            <td><strong>kubectl exec</strong></td>
            <td>Run command inside a pod</td>
            <td><code>kubectl exec -it myapi-pod-123 bash</code></td>
          </tr>
          <tr>
            <td><strong>kubectl scale</strong></td>
            <td>Change number of replicas</td>
            <td><code>kubectl scale deployment myapi --replicas=10</code></td>
          </tr>
          <tr>
            <td><strong>kubectl set image</strong></td>
            <td>Update to new image version (triggers rolling update)</td>
            <td>
              <code
                >kubectl set image deployment/myapi
                myapi=acr.azurecr.io/myapi:2.0</code
              >
            </td>
          </tr>
          <tr>
            <td><strong>kubectl delete</strong></td>
            <td>Delete deployment and all its pods</td>
            <td><code>kubectl delete deployment myapi</code></td>
          </tr>
          <tr>
            <td><strong>kubectl rollout undo</strong></td>
            <td>Rollback to previous working deployment</td>
            <td><code>kubectl rollout undo deployment/myapi</code></td>
          </tr>
        </tbody>
      </table>

      <table>
        <thead>
          <tr>
            <th>Tool</th>
            <th>What it is</th>
            <th>When to use</th>
            <th>Complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Docker</strong></td>
            <td>Package app into container</td>
            <td>Dev, testing, single server deployment</td>
            <td>‚≠ê Easy</td>
          </tr>
          <tr>
            <td><strong>Azure App Service</strong></td>
            <td>Managed hosting ‚Äî Azure handles everything</td>
            <td>Small-medium app, no server management</td>
            <td>‚≠ê‚≠ê Medium</td>
          </tr>
          <tr>
            <td><strong>Kubernetes (AKS)</strong></td>
            <td>Orchestrate 100s‚Äì1000s of containers across many servers</td>
            <td>Large scale, auto-scaling, complex deployments</td>
            <td>‚≠ê‚≠ê‚≠ê Hard</td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>Kubernetes Best Practices:</strong></p>
        <ul>
          <li>
            <strong>Never use <code>latest</code> tag</strong> ‚Äî always specify
            version (<code>myapi:1.2.3</code>). <code>latest</code> is
            unpredictable across different servers.
          </li>
          <li>
            <strong>Set resource limits</strong> ‚Äî specify CPU and memory per
            pod. Prevents one pod from consuming all resources and crashing
            others.
          </li>
          <li>
            <strong>Add liveness probes</strong> ‚Äî K8s pings your health
            endpoint. Unhealthy pods are restarted automatically.
          </li>
          <li>
            <strong>Use Namespaces</strong> ‚Äî separate dev, staging, prod to
            prevent accidents and ease management.
          </li>
          <li>
            <strong>Use Secrets for credentials</strong> ‚Äî passwords and API
            keys are encrypted; never put them in YAML files.
          </li>
          <li>
            <strong>Use ConfigMaps for config</strong> ‚Äî change settings without
            rebuilding the image.
          </li>
        </ul>
      </div>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <!-- ===================== SECTION 5 ===================== -->
    <h2 class="section-header" onclick="toggleSection(this)">
      SECTION 5: Complete DevOps Workflow (End-to-End)
      <span class="toggle-icon">‚ñº</span>
    </h2>
    <div class="section-content">
      <table>
        <thead>
          <tr>
            <th>Phase</th>
            <th>What happens</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>DEVELOP</strong></td>
            <td>
              Write C# API ‚Üí create Dockerfile ‚Üí write pipeline YAML ‚Üí
              <code>git push origin main</code>
            </td>
          </tr>
          <tr>
            <td><strong>BUILD</strong></td>
            <td>
              Git push triggers pipeline ‚Üí <code>dotnet build</code> ‚Üí
              <code>dotnet test</code> ‚Üí build Docker image ‚Üí push to ACR with
              version tag
            </td>
          </tr>
          <tr>
            <td><strong>DEPLOY</strong></td>
            <td>
              Auto-deploy to Dev ‚Üí Approval gate ‚Üí Deploy to Staging ‚Üí QA
              testing ‚Üí Final approval ‚Üí Deploy to Production
            </td>
          </tr>
          <tr>
            <td><strong>RUN</strong></td>
            <td>
              Kubernetes / App Service runs container ‚Üí 5 replicas load-balanced
              ‚Üí K8s health checks ‚Üí auto-heal on crash ‚Üí auto-scale on traffic
              spike ‚Üí Application Insights monitors everything
            </td>
          </tr>
        </tbody>
      </table>

      <div class="note">
        <p><strong>Full Flow in One Line:</strong></p>
        <p>
          Developer pushes code ‚Üí Pipeline builds &amp; tests ‚Üí Docker image
          pushed to ACR ‚Üí Deployed to Dev ‚Üí Approval ‚Üí Staging ‚Üí Approval ‚Üí
          Production ‚Üí Kubernetes runs, heals, and scales automatically ‚Üí
          Application Insights monitors
        </p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Benefit</th>
            <th>What it means</th>
            <th>Impact</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Faster deployment</strong></td>
            <td>Deploy in minutes, not days</td>
            <td>Respond to issues and ship features faster</td>
          </tr>
          <tr>
            <td><strong>Higher reliability</strong></td>
            <td>Automated tests catch bugs before prod</td>
            <td>Fewer outages, better user experience</td>
          </tr>
          <tr>
            <td><strong>Auto-scaling</strong></td>
            <td>Traffic spike? More pods created automatically</td>
            <td>Always responsive, no manual action needed</td>
          </tr>
          <tr>
            <td><strong>Self-healing</strong></td>
            <td>Pod crashes? New one starts automatically</td>
            <td>Zero downtime even during failures</td>
          </tr>
          <tr>
            <td><strong>Easy rollback</strong></td>
            <td>Bad deployment? Roll back to previous version instantly</td>
            <td>Minimal damage, fast recovery</td>
          </tr>
          <tr>
            <td><strong>Consistent environments</strong></td>
            <td>Dev, staging, prod all run same Docker image</td>
            <td>"Works on my machine" problem solved forever</td>
          </tr>
          <tr>
            <td><strong>Cost optimization</strong></td>
            <td>Auto-scale down when traffic is low</td>
            <td>Pay only for what you actually use</td>
          </tr>
        </tbody>
      </table>

      <div class="image-icons">
        <span class="image-icons-label">Images:</span>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
        <button class="image-icon" onclick="toggleImage(this)" data-src="">
          üì∑
        </button>
      </div>
      <div class="image-preview-box"></div>
    </div>

    <script src="../change.js"></script>
  </body>
</html>
